<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  
  <!--[if lt IE 9]>
  <script src="/lib/html5shim.js"></script>
  <![endif]-->  
  
  <!-- These are some core styles the slideshow app requires -->
  <link rel="stylesheet" href="/lib/styles.css" />
  
  <!-- These are the styles you'll add to make the slides look great -->
  <link rel="stylesheet" href="/css/styles.css" />
  <link rel="stylesheet" href="/css/prism.css" />
  
  <title>x86 Assembly Language</title>
</head>
<body>
  <header>
      <h1>An Introduction to x86 Assembly Language</h1>
    <nav>
      <ul>
        <li><button id="prev-btn" title="Previous slide">Previous Slide</button></li>
        <li><span id="slide-number"></span>/<span id="slide-total"></span></li>
        <li><button id="next-btn" title="Next Slide">Next Slide</button></li>
      </ul>
    </nav>
  </header>
  <div id="deck">
    
    <!-- Begin slides -->
    <section>
      <hgroup>
        <h1>An Introduction to x86 Assembly Language</h1>
        <h2>Basic Instructions and Shellcode</h2>
      </hgroup>
      <p>
      Most desktop or laptop computers in the world run some variant of the
      x86 processor.  Thus, the most common ISA used in computer security
      is x86.  Knowledge of x86 is necessary for understanding how to both
      reverse engineer and exploit binaries.
      </p>
    </section>
    <section>
      <hgroup>
        <h1>Why Assembly?</h1>
      </hgroup>
      <ul>
        <li>Many computer exploit techniques are fundamentally low level
          <ul>
            <li>Reverse engineering is done at the assembly level</li>
            <li>Exploit payloads are (usually) written in assembly</li>
          </ul>
        </li>
        <li>BLUF:  C isn't close enough to the metal to conduct real
          exploits</li>
      </ul>
    </section>
    <section>
      <hgroup>
        <h1>x86 ISA Overview</h1>
        <h2>Or, why x86 sucks</h2>
      </hgroup>
      <ul>
        <li>Not easy like MIPS...</li>
        <li>Little Endian (0xdeadbeef is |ef|be|ad|de|)</li>
        <li>CISC Architecture evolving from a 16-bit ISA
          <ul>
            <li>This is why a 'word' in x86 refers to two bytes</li>
            <li>Thus, a 32-bit figure is a <b>dword</b> (64-bit is a
              <b>qword</b>)</li>
          </ul>
        <li>Many variants (read: <em>complex</em>)</li>
        <li>BUT: It's everywhere
          <ul>
            <li>Business concerns trump technical concerns every time</li>
          </ul>
        </li>
    </section>
    <section>
      <hgroup>
        <h1>A Note on Syntax</h1>
      </hgroup>
      <ul>
        <li>There are two syntax styles used in x86:
          <ul>
            <li>Intel Syntax</li>
            <li>AT&amp;T Syntax</li>
          </ul>
        </li>
        <li>We'll be using Intel Syntax
          <ul>
            <li>I am going to (somewhat arbitrarily) say that it's easier
              and more intuitive</li>
            <li>If you see lots of %s and $s, it's probably AT&amp;T</li>
            <li>Lots of small syntax changes that will trip you up</li>
          </ul>
        </li>
      </ul>
    </section>
    <section>
      <hgroup>
        <h1>Brief Note on Segments</h1>
        <h2>Deprecated stuff you can (mostly) ignore</h2>
      </hgroup>
      <ul>
          <li>There are segment registers</li>
          <li>CS, DS, ES, FS, GS, SS</li>
          <li>Pretend they don't exist</li>
          <li>Relic of old 16-bit processors</li>
          <li>After the invention of paging, segments fell out of favor</li>
          <li>Now all they're there for is backwards compatibility</li>
      </ul>
    </section>    
    <section>
      <hgroup>
        <h1>Sections of a Process Image</h1>
      </hgroup>
      <div style="float:left">
        <ul>
            <li><code>.data</code>
              <ul><li>Initialized Data</li></ul>
            </li>
            <li><code>.bss</code>
              <ul><li>Uninitialized Data (set to 0)</li></ul>
            </li>
            <li><code>.text</code>
              <ul><li>Code</li>
                  <li>Entry Point (<code>_start</code>)</li></ul>
            </li>
            <li>The Stack
              <ul><li>Local variables</li></ul>
            </li>
            <li>The Heap
              <ul><li>Dynamically allocated memory (malloc/new)</li></ul>
            </li>
        </ul>
      </div>
      <div style="float:left;margin-left:10em">
<pre class="language-nasm"><code>
section .data:
    message: db 'Hello World!'
    bufsz:   dd 1024
section .bss:
    fname:   resb 255
    num:     resd 1
section .text:
global _start
_start:
    (...)
    call main
    (...)
</code></pre>
        </div>
        <div style="clear:both;"></div>
    </section>
    <section>
        <hgroup>
            <h1>Memory Layout</h1>
        </hgroup>
<pre>
+=============+
|    Stack    | ~0xff8e0000
+-------------+
|   Lots of   |
|    Empty    |
|    Space    |
+-------------+
|    Heap     | ~0x993a0000
+-------------+
|   Lots of   |
|    Empty    |
|    Space    |
+-------------+
|    .bss     |
+-------------+
|   .data     |
+-------------+
|   .text     | ~0x08040000
+-------------+
</pre>
    </section>
    <section>
        <hgroup>
            <h1>Registers</h1>
        </hgroup>
        <ul>
            <li>General Purpose (eax, ebx, ecx, edx)
            <ul>
                <li>Leftovers from the 16-bit days</li>
                <li>ax, bx, cx, and dx refer to low 16 bits</li>
                <li>?h refers to the high 8 bits of ?x</li>
                <li>?l refers to the low 8 bits of ?x</li>
            </ul></li>
            <li>Stack Pointer (esp)</li>
            <li>Base Pointer (ebp)</li>
            <li>Index Registers (edi, esi)
            <ul>
                <li>These are GPRs that also have special instructions</li>
            </ul></li>
        </ul>
        <p> Register naming example: </p>
<pre>
         +----------------+--------+--------+
     eax |             ax |   ah   |   al   |
         +----------------+--------+--------+
</pre>
    </section>
    <section>
      <hgroup>
        <h1>Standard Instructions</h1>
        <h2>The Basics</h2>
      </hgroup>
      <p> Note that at most one argument to an instruction may be a
          memory argument, and at least one argument must be a
          register (some exceptions). </p>
      <table><tbody>
          <tr>
              <td> mov eax, ebx </td> 
              <td> eax = ebx; </td>
          </tr>
          <tr>
              <td> add eax, ebx </td>
              <td> eax += ebx; </td>
          </tr>
          <tr>
              <td> sub eax, ebx </td>
              <td> eax -= ebx; </td>
          </tr>
          <tr>
              <td> inc eax </td>
              <td> ++eax; </td>
          </tr>
          <tr>
              <td> dec eax </td>
              <td> --eax; </td>
          </tr>
          <tr>
              <td> call foo </td>
              <td> foo(); </td>
          </tr>
          <tr>
              <td> ret </td>
              <td> return eax; </td>
          </tr>
          <tr>
              <td> push 10h </td>
              <td> *--esp = 0x10; </td>
          </tr>
          <tr>
              <td> pop eax </td>
              <td> eax = *esp++; </td>
          </tr>
      </tbody></table>
    </section>
    <section>
      <hgroup>
        <h1>Memory Addressing</h1>
        <h2>Syntax</h2>
      </hgroup>
      <ul>
        <li>Memory references are always surrounded by brackets, like [esp]
            (equlvalent to *esp)</li>
        <li>Labels are by default pointers, so references to the value of
            global variables look like [foo]</li>
        <li>Most instructions can take <b>at most one</b> memory reference</li>
        <li>Each memory reference can have <b>up to</b> three components:
          <ul>
            <li>Base Address (Register)</li>
            <li>Index (Register) * ElemSize (1, 2, 4, or 8)</li>
            <li>Displacement (Constant)</li>
          </ul>
        </li>
      </ul>
      <br />
      <pre><code>[Base + Index*ElemSize &plusmn; Displacement]</code></pre>
    </section>
    <section>
      <hgroup>
        <h1>Memory Addressing</h1>
        <h2>Examples</h2>
      </hgroup>
      <ul>
        <li>[eax] is equivalent to *eax</li>
        <li>[ebp-8] is equivalent to *(ebp-8)</li>
        <li>[esp+eax*4+0x20] is equivalent to ((int*)(esp+0x20))[eax]</li>
        <li>[0xdeadbeef] is equivalent to *((int*)0xdeadbeef)</li>
        <li>[foo] is equivalent to *foo where foo is a global pointer</li>
        <li>Basically: Think [] implies dereference (*)</li>
      <ul>
    </section>
    <section>
      <hgroup>
        <h1>The LEA instruction</h1>
        <h2>Load Effective Address</h2>
      </hgroup>
      <ul>
        <li>A lot of the time we want to load some address to use later</li>
        <li>We can legally do something like <code>mov eax,[esp+8]</code></li>
        <li>However, to get the address, <code>mov eax,esp+8</code> is illegal</li>
        <li>So, we use the LEA instruction: <code>lea eax,[esp+8]</code></li>
        <li>With LEA we can take the address of a memory reference and load it</li>
        <li>Basically: LEA is always used with [], and it loads the address of its
            argument instead.</li>
      </ul>
    </section>
    <section>
      <div style="float:left">
      <hgroup>
        <h1>The Stack</h1>
        <h2>Overview</h2>
      </hgroup>
      <ul>
        <li>The stack grows DOWNWARD<ul>
            <li>Top of the stack: lowest memory address</li></ul>
        </li>
        <li>The esp register points to the top of the stack<ul>
            <li>Adding to esp removes items from the stack</li>
            <li>Subtracting to esp adds items to the stack</li></ul>
        </li>
      </ul></div>
      <img style="float:left;padding-left:10em" src="/images/stack_overview.svg" />
      <div style="clear:both"></div>
    </section>
    <section>
      <hgroup>
        <h1>Stack Frames and Calling Conventions</h1>
      </hgroup>
      <div style="float:left">
      <br />
      <ul>
        <li>Caller pushes args on to stack, right to left</li>
        <li>Caller executes call instruction<ul>
            <li>call instruction pushes return address on to the stack</li></ul>
        </li>
        <li>Callee pushes ebp onto stack, sets ebp to esp</li>
        <li>Callee then allocates space for local variables</li>
        <li>Return value is in eax</li>
        <li>eax, ecx, edx are caller-saved (all others callee-saved)</li>
        <li>After return, caller responsible for cleaning arguments off the stack</li>
      </ul>
      </div>
      <img style="float:left" src="/images/stack_frame.svg" />
      <div style="clear:both"></div>
    </section>
    <section>
      <hgroup>
        <h1>Function Example</h1>
      </hgroup>
<pre style="float:left" class="language-c"><code>
int identity(int x) {
    return x;
}
</code></pre>
<pre style="float:left;margin-left:10em" class="language-nasm"><code>
global identity
identity:
    push ebp            ; prologue
    mov ebp, esp        ;
    mov eax, [ebp+8]    ; do actual work
    mov esp, ebp        ; epilogue
    pop ebp             ;
    ret                 ; return
</code></pre>
      <div style="clear:both"></div>
    </section>
    <section>
      <hgroup>
        <h1>Function Call Example</h1>
      </hgroup>
<pre style="float:left" class="language-c"><code>
ebx = identity(ebx);
</code></pre>
<pre style="float:left;margin-left:10em" class="language-nasm"><code>
push ebx         ; push arguments on the stack
call identity    ; call function
add esp, 4       ; clean up passed arguments
mov ebx, eax     ; put return value where we want it
</code></pre>
      <div style="clear:both"></div>
    </section>
    <section>
      <hgroup>
        <h1>A quick note on ebp</h1>
        <h2>What's the frame pointer for</h2>
      </hgroup>
      <ul>
        <li>Constant location (esp changes when you ex. push/pop)<ul>
            <li>I cannot stress enough how much simpler this makes complex code</li></ul>
        </li>
        <li>Provides a linked list of stack frames (useful for debugging)</li>
        <li>That said, some compilers don't use it<ul>
            <li>GCC has the -fomit-frame-pointer option</li>
            <li>This breaks some debuggers though</li>
            <li>Some functions need the frame pointer though:<ul>
                <li>alloca()</li>
                <li>C99 VLAs</li></ul>
            </li></ul>
        </li>
      </ul>
    </section>
    <section>
      <hgroup>
        <h1>Tips to Success</h1>
      </hgroup>
      <ul>
        <li>DRAW THE STACK OUT</li>
        <li>Update your stack diagram as things are changed in memory</li>
        <li>Keep track of which addresses refer to which variables</li>
        <li>Know what is in all of the registers at all times</li>
      </ul>
    </section>
    <section>
      <hgroup>
        <h1>A complete program: Hello World</h1>
      </hgroup>
<pre class="language-nasm"><code>
[BITS 32]

section .data:
    msg:    db `Hello, World!\n\0`  ; use backticks for the string
                                    ; note that we need to manually add the \0

section .text:
    extern printf           ; have to declare what functions we use
    global main             ; main is a global symbol (accessible from other files)

main:
    push ebp                ; standard prologue
    mov ebp, esp            ;
    push msg                ; push msg onto the stack (to use as an arg)
    call printf             ; printf(msg)
    add esp, 4              ; clean up the arg we pushed
    mov eax, 0              ; put return code in eax
    mov esp, ebp            ; standard epilogue
    pop ebp                 ;
    ret                     ;
</code></pre>
    </section>
    <section>
      <hgroup>
        <h1>Another Function Example</h1>
      </hgroup>
<pre style="float:left" class="language-c"><code>
void vulnerable() {
    char buf[256];
    gets(buf);
}
</code></pre>
<pre style="float:left;margin-left:10em" class="language-nasm"><code>
global vulnerable
vulnerable:
    push ebp            ; prologue
    mov ebp, esp        ;
    sub esp, 256        ; allocate space on stack for buf
    lea eax, [ebp-256]  ; load address of buf
    push eax            ; push args onto stack
    call gets           ; perform function call
    mov esp, ebp        ; epilogue
    pop ebp             ;
    ret                 ; return
</code></pre>
      <div style="clear:both"></div>
    </section>
    <section>
      <hgroup>
        <h1>Exploit Techniques</h1>
      </hgroup>
      <ul>
        <li>Return address is on the stack!</li>
        <li>Most common attack: overflow a stack buffer, overwrite return addr</li>
        <li>Vulnerable functions: gets(), scanf("%s"), strcpy()</li>
        <li>Overwrite the return address to run arbitrary</li>
        <li>Lots of techniques, varying degrees of sophistication</li>
        <li>Some defenses to mitigate dangers (more on this later...)</li>
      </ul>
    </section>
    <section>
      <hgroup>
        <h1>Branching</h1>
      </hgroup>
      <ul>
        <li>Unconditional branch: use the jmp instruction</li>
        <li>Conditional Branching has two steps: check, then jump</li>
        <li>Two different instructions for the check step:<ul>
            <li>test instruction: use to check if something is zero<ul>
                <li>Most commonly: arguments should be the same e.g. <code>test eax, eax</code></li>
                <li>Can use the jz (jump if zero) and jnz (jump if not zero) commands after a test</li></ul>
            </li>
            <li>cmp instruction: compare two numbers<ul>
                <li>Use like <code>cmp a, b</code></li>
                <li>Can use je (==) or jne (!=)</li>
                <li>Signed arguments: use jl (&lt;), jle (&lt;=), jge (&gt;=), jg (&gt;)</li>
                <li>Unsigned arguments: use jb (jump if below, &lt;), jbe (&lt;=), jae (&gt;=), ja (jump if above, &gt;)</li>
            </ul></li>
        </ul></li>
      </ul>
    </section>
    <section>
      <hgroup>
        <h1>Multiplication/Division (with bigger numbers)</h1>
        <h2>If you actually care...</h2>
      </hgroup>
      <ul>
        <li><code>mul reg</code> performs eax*reg and stores the result in edx:eax</li>
        <li>Above notation means that edx stores the overflow (i.e. result == edx*2<sup>32</sup> + eax)</li>
        <li>imul is the same, but for signed numbers</li>
        <li><code>div reg</code> divides edx:eax by reg and stores the result in eax, remainder in edx</li>
        <li>If there is overflow (i.e. result cannot fit in eax) the result is undefined/may crash</li>
        <li>idiv is the same again, but for signed numbers</li>
      </ul>
    </section>
    <section>
      <hgroup>
        <h1>Another Function Example</h1>
      </hgroup>
<pre style="float:left" class="language-nasm action"><code>
global foo
foo:
    push ebp
    mov ebp, esp
    mov eax, [ebp+8]
    test eax, eax
    jnz bar
    inc eax
    jmp baz
bar:
    dec eax
    push eax
    call foo
    pop ecx
    inc ecx
    mul ecx
baz:
    mov esp, ebp
    pop ebp
    ret
</code></pre>
<pre style="float:left;margin-left:10em" class="language-c action"><code>
int fact(int x) {
    if (x == 0) return 1;
    return x * fact(x - 1);
}
</code></pre>
      <div style="clear:both"></div>
    </section>
    <section>
      <hgroup>
        <h1>Is assembly faster than C?</h1>
      </hgroup>
      <ul>
        <li class="action">YES, in a quick non-scientific benchmark (of previous slide), speedup = 1.196</li>
        <li class="action">BUT compilers have this awesome thing called optimization mode...<ul>
            <li>gcc -O1 is 1.327 times faster than assembly</li>
            <li>gcc -O4 is 4.565 times faster than assembly</li>
        </ul></li>
        <li class="action">Moral of the story is, while assembly is important for RevEng...<ul>
            <li>You probably won't beat a compiler with optimizations. They're <b>really good</b> at this shit</li>
            <li>The best performance: have the compiler optimize C, then tweak assembly as needed</li>
        </ul></li>
        <li class="action">Rule #1 of performance: <b>BENCHMARK</b>. #PrematureOptimizationIsTheRootOfAllEvil</li>
      </ul>
    </section>
    <section>
      <hgroup>
        <h1>System Calls</h1>
      </hgroup>
      <ul>
        <li>How user processes invoke the kernel</li>
        <li>Activated by triggering interrupt 0x80</li>
        <li>man section 2 covers syscalls (same as in C)</li>
        <li>Separate calling convention though:<ul>
            <li>Syscall # in eax (see &lt;asm/unistd_32.h&gt;)</li>
            <li>Args (left to right on manpage) in ebx, ecx, edx, esi, edi, ebp</li>
            <li>Return value is in eax</li>
            <li>Values in range [-4095, -1] indicate an error</li>
        </ul></li>
      </ul>
    </section>
    <section>
      <hgroup>
        <h1>Hello World, with System Calls</h1>
        <h2>Look Mom, no C library!</h2>
      </hgroup>
<pre class="language-nasm"><code>
[BITS 32]

section .data:
    hello:      db `Hello, World!\n`  ; this time, don't need \0
    helloLen:   dd $-hello            ; string length

section .text:
    global _start
    
_start:                     ; not using C, use _start instead of main
    mov eax, 4              ; write() syscall number
    mov ebx, 1              ; fd (STDOUT_FILENO)
    mov ecx, hello          ; data (pointer) to write
    mov edx, [helloLen]     ; number of bytes to write
    int 0x80                ; call kernel
    mov eax, 1              ; exit() syscall number
    mov ebx, 0              ; return code (0)
    int 0x80                ; call kernel
                            ; NOTE: we cannot return from _start, must exit()
</code></pre>
    </section>
    <section>
      <hgroup>
        <h1>Shellcode Example</h1>
      </hgroup>
<pre class="language-nasm"><code>
[BITS 32]

; Note that we MUST have a valid stack for this to work!

xor ecx, ecx       ; zero ecx
mul ecx            ; edx:eax = eax*ecx, i.e. zeros edx and eax
mov al, 0xb        ; set eax to 0xb, syscall number for execve
push ecx           ; pushes a zero onto the stack (stack is \0\0\0\0)
push '//sh'        ; push '//sh' onto stack (stack is //sh\0\0\0\0)
push '/bin'        ; push '/bin' onto stack (stack is /bin//sh\0\0\0\0)
mov ebx, esp       ; set ebx (arg1: path) to stack pointer ('/bin//sh')
push ecx           ; push another zero (execve needs a NULL at the end)
push ebx           ; push addr of "/bin//sh"
mov ecx, esp       ; set ecx (arg2: argv) to ["/bin//sh", 0]
                   ; edx (arg3: envp) is already NULL from `mul ecx`
int 80h            ; perform system call
</code></pre>
    </section>
  </div>
  <!-- /deck -->
  <script src="/lib/jquery-1.5.2.min.js"></script>
  <script src="/lib/jquery.jswipe-0.1.2.js"></script>  
  <script src="/lib/htmlSlides.js"></script>
  <script src="/lib/prism.js"></script>
  <script src="/lib/trim.js"></script>
  <script>
    //Do our business when the DOM is ready for us
    $(function() {
      //One little option: hideToolbar (boolean; default = false)
      htmlSlides.init({ hideToolbar: true });
      
    });
  </script>
  </body>
</html>
